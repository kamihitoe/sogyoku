{"/about/":{"data":{"":"别急"},"title":"关于"},"/glossary":{"data":{},"title":"Glossary"},"/life/%E5%94%89-2/":{"data":{"":"唉"},"title":"唉"},"/life/%E5%94%89/":{"data":{"":"唉"},"title":"唉"},"/misc/%E7%97%9B%E3%81%BF%E3%81%AF%E7%94%9F%E3%81%8D%E7%B6%9A%E3%81%91%E3%82%8B%E3%81%93%E3%81%A8%E3%81%AE%E5%AF%BE%E4%BE%A1%E3%81%A0/":{"data":{"":"痛みは生きている証だ"},"title":"痛みは生き続けることの対価だ"},"/note/%E5%B9%B6%E6%9F%A5%E9%9B%86-dsu/":{"data":{"":"","模板#模板":"cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include #include struct DSU { vector\u003cll\u003e f, sz; ll sets; // 连通块个数 DSU(ll n) : f(n+1), sz(n+1, 1), sets(n) { iota(f.begin(), f.end(), 0); } ll find(ll x) { while (x != f[x]) x = f[x] = f[f[x]]; // 路径减半 return x; } void merge(ll x, ll y) { x = find(x), y = find(y); if (x == y) return; if (sz[x] \u003c sz[y]) swap(x, y); // 按规模合并 f[y] = x; sz[x] += sz[y]; sets--; } };"},"title":"并查集 (DSU)"},"/note/%E6%A8%A1%E6%84%8F%E4%B9%89%E4%B8%8B%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C/":{"data":{"":"","代码实现#代码实现":"暴力枚举复杂度 O(n2)O(n^2)O(n2) ．\n可利用支持高效插入和查找的数据结构优化“查找最小的大于 SrS_rSr​ 的 Sl−1S_{l-1}Sl−1​”操作．如在 C++ 中可使用基于红黑树的 std::set 实现，单次操作复杂度为 O(log⁡n)O(\\log n)O(logn)．","分析#分析":"显然 Kadane 算法不可行．考虑前缀和角度：\n设 SSS 为数组 AAA 模 mmm 意义下的前缀和数组，约定 S0=0S_0 = 0S0​=0 ．则\n(∑k=lrak) mod m=(Sr−Sl−1+m) mod m \\left( \\sum_{k=l}^{r} a_k \\right) \\bmod m = (S_r - S_{l-1} + m) \\bmod m (k=l∑r​ak​)modm=(Sr​−Sl−1​+m)modm固定右端点 rrr ，根据 SrS_rSr​ 和 Sl−1S_{l-1}Sl−1​ 的大小关系分讨：\nSr≥Sl−1S_r \\ge S_{l-1}Sr​≥Sl−1​： 此时 (Sr−Sl−1+m) mod m=Sr−Sl−1(S_r - S_{l-1} + m) \\bmod m = S_r - S_{l-1}(Sr​−Sl−1​+m)modm=Sr​−Sl−1​ ． 显然 Sl−1S_{l-1}Sl−1​ 取 S0=0S_0=0S0​=0 时该值最大．此时模意义下子段和 =Sr= S_r=Sr​ ．\nSr\u003cSl−1S_r \u003c S_{l-1}Sr​\u003cSl−1​： 此时 (Sr−Sl−1+m) mod m=Sr−Sl−1+m(S_r - S_{l-1} + m) \\bmod m = S_r - S_{l-1} + m(Sr​−Sl−1​+m)modm=Sr​−Sl−1​+m． 为使该值最大，则需 Sl−1S_{l-1}Sl−1​ 最小，故 Sl−1S_{l-1}Sl−1​ 应取大于 SrS_rSr​ 的最小值．此时模意义下子段和 \u003eSr\u003e S_r\u003eSr​ ．","复杂度#复杂度":"时间复杂度：O(nlog⁡n)O(n \\log n)O(nlogn)． 空间复杂度：O(n)O(n)O(n)．","示例#示例":"cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include #include using namespace std; using ll = long long; ll solve(const vector\u003cll\u003e\u0026 a, ll n, ll m) { ll ans = 0, sum = 0; set\u003cll\u003e s; s.insert(0); for (ll i = 1; i \u003c= n; i++) { sum = (sum + a[i] % m + m) % m; auto it = s.upper_bound(sum); if (it != s.end()) { ans = max(ans, sum - *it + m); } else { ans = max(ans, sum); } s.insert(sum); } return ans; }","题面#题面":"给定长度为 nnn 的数组 A={a1,a2,…,an}A = \\{a_1, a_2, \\dots, a_n\\}A={a1​,a2​,…,an​} 和模数 mmm ，求数组 AAA 模 mmm 意义下的最大子段和．\n形式化地，求： max⁡1≤l≤r≤n((∑k=lrak) mod m) \\max_{1 \\le l \\le r \\le n} \\left( \\left( \\sum_{k=l}^{r} a_k \\right) \\bmod m \\right) 1≤l≤r≤nmax​((k=l∑r​ak​)modm)"},"title":"模意义下最大子段和"}}